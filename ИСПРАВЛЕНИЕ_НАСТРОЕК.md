# Исправление применения настроек бота

## Проблема

При изменении настроек через меню `/settings`, значения успешно сохранялись в хранилище, но бот продолжал использовать старые (глобальные) значения. Это было проверено на `MESSAGE_GROUP_TIMEOUT`, но затрагивало все настройки.

### Причина

Бот создавал компоненты один раз при запуске с глобальными настройками:
- `MessageAggregator` - создавался с `settings.MESSAGE_GROUP_TIMEOUT = 30` при старте
- `Agent` - создавался с глобальными настройками через `AgentFactory.from_settings(settings)`

Когда пользователь менял настройки, они сохранялись в `./data/user_settings_overrides.json`, но бот никогда не перечитывал эти значения и продолжал использовать старые экземпляры компонентов.

## Решение

### 1. Компоненты для каждого пользователя

Вместо одного глобального `MessageAggregator` и `Agent` для всех пользователей, теперь каждый пользователь получает свои экземпляры с индивидуальными настройками:

```python
# Было (глобально):
self.message_aggregator = MessageAggregator(settings.MESSAGE_GROUP_TIMEOUT)
self.agent = AgentFactory.from_settings(settings)

# Стало (для каждого пользователя):
self.user_message_aggregators: Dict[int, MessageAggregator] = {}
self.user_agents: Dict[int, Any] = {}
```

### 2. Ленивая инициализация

Компоненты создаются при первом обращении с актуальными настройками пользователя:

```python
def _get_or_create_user_aggregator(self, user_id: int):
    if user_id not in self.user_message_aggregators:
        # Получаем ТЕКУЩЕЕ значение настройки пользователя
        timeout = self.settings_manager.get_setting(user_id, "MESSAGE_GROUP_TIMEOUT")
        aggregator = MessageAggregator(timeout)
        self.user_message_aggregators[user_id] = aggregator
    return self.user_message_aggregators[user_id]
```

### 3. Инвалидация кэша при изменении настроек

Когда пользователь меняет настройку, его кэшированные компоненты удаляются:

```python
def invalidate_user_cache(self, user_id: int):
    """Удаляет кэшированные компоненты пользователя"""
    if user_id in self.user_message_aggregators:
        self.user_message_aggregators[user_id].stop_background_task()
        del self.user_message_aggregators[user_id]
    
    if user_id in self.user_agents:
        del self.user_agents[user_id]
```

При следующем сообщении компоненты будут пересозданы с новыми настройками.

### 4. Обновлены все точки использования настроек

Все места, где использовались `settings.SETTING_NAME`, теперь используют:
```python
value = self.settings_manager.get_setting(user_id, "SETTING_NAME")
```

Это включает:
- `MESSAGE_GROUP_TIMEOUT` - таймаут группировки сообщений
- `KB_GIT_ENABLED` - включение Git для базы знаний
- `KB_GIT_AUTO_PUSH` - автопуш в удаленный репозиторий
- `KB_GIT_REMOTE` - имя remote
- `KB_GIT_BRANCH` - ветка Git
- Все настройки агента (тип, модель, таймауты, возможности)

## Измененные файлы

1. **src/bot/handlers.py** (+105 строк)
   - Добавлены словари для хранения пользовательских компонентов
   - Добавлены методы создания и инвалидации компонентов
   - Обновлена обработка сообщений для использования пользовательских настроек

2. **src/bot/settings_handlers.py** (+20 строк)
   - Добавлена ссылка на handlers для инвалидации кэша
   - Все методы изменения настроек теперь вызывают `invalidate_user_cache()`

3. **src/bot/telegram_bot.py** (+8 строк)
   - Изменен порядок инициализации для кросс-ссылок

## Как это работает теперь

1. **Пользователь меняет настройку** через `/settings`
2. **Настройка сохраняется** в `./data/user_settings_overrides.json`
3. **Кэш инвалидируется** - удаляются MessageAggregator и Agent пользователя
4. **Следующее сообщение** от пользователя запускает пересоздание компонентов
5. **Новые компоненты создаются** с обновленными настройками
6. **Бот использует новые настройки** сразу же! ✅

## Тестирование

### Тест MESSAGE_GROUP_TIMEOUT

```
1. Отправьте /settings
2. Выберите Processing → MESSAGE_GROUP_TIMEOUT
3. Измените с 30 на 10 секунд
4. Отправьте несколько сообщений
5. Проверьте, что они группируются через 10 секунд, а не 30
```

### Тест KB_GIT_ENABLED

```
1. Отправьте /settings
2. Выберите Knowledge Base → KB_GIT_ENABLED
3. Отключите (false)
4. Отправьте сообщение → проверьте, что нет коммита
5. Включите (true)
6. Отправьте сообщение → проверьте, что коммит создан
```

### Тест AGENT_TIMEOUT

```
1. Отправьте /settings
2. Выберите Agent → AGENT_TIMEOUT
3. Измените с 300 на 60 секунд
4. Отправьте сообщение, требующее обработки
5. Убедитесь, что таймаут срабатывает через 60 секунд
```

### Тест изоляции пользователей

```
1. Пользователь A: установить MESSAGE_GROUP_TIMEOUT = 10
2. Пользователь B: установить MESSAGE_GROUP_TIMEOUT = 60
3. Оба отправляют сообщения
4. У каждого работает свой таймаут! ✅
```

## Преимущества

✅ Настройки применяются немедленно, без перезапуска бота
✅ Каждый пользователь может иметь свои настройки
✅ Автоматическая очистка старых компонентов при изменении настроек
✅ Ленивая инициализация экономит память для неактивных пользователей
✅ Чистое разделение между глобальными значениями по умолчанию и пользовательскими переопределениями

## Какие настройки теперь работают правильно

Все настройки теперь применяются на уровне пользователя:

**Обработка:**
- `MESSAGE_GROUP_TIMEOUT` - таймаут группировки сообщений (секунды)

**База знаний:**
- `KB_GIT_ENABLED` - включить Git интеграцию
- `KB_GIT_AUTO_PUSH` - автоматический push в remote
- `KB_GIT_REMOTE` - имя remote (обычно "origin")
- `KB_GIT_BRANCH` - ветка Git (обычно "main")

**Агент:**
- `AGENT_TYPE` - тип агента (stub, qwen_code, qwen_code_cli)
- `AGENT_MODEL` - модель для агента
- `AGENT_TIMEOUT` - таймаут обработки агента (секунды)
- `AGENT_INSTRUCTION` - инструкция для агента
- `AGENT_ENABLE_WEB_SEARCH` - включить веб-поиск
- `AGENT_ENABLE_GIT` - включить Git операции
- `AGENT_ENABLE_GITHUB` - включить GitHub операции
- `AGENT_ENABLE_SHELL` - включить shell команды
- `AGENT_QWEN_CLI_PATH` - путь к Qwen CLI

И все остальные настройки из `config/settings.py`!

## Дополнительная документация

- `SETTINGS_FIX_SUMMARY.md` - детальное техническое описание (English)
- `SETTINGS_FLOW_DIAGRAM.md` - диаграммы потоков до/после исправления (English)
