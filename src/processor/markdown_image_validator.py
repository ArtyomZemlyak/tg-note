"""
Markdown Image Path Validator
Validates image paths in markdown files generated by agents.
"""

import os
import re
from pathlib import Path, PurePosixPath
from typing import Dict, List, Optional, Set, Tuple

from loguru import logger


class ImageReference:
    """Represents an image reference found in markdown."""

    def __init__(
        self,
        alt_text: str,
        path: str,
        line_number: int,
        markdown_file: Path,
        resolved_path: Optional[Path] = None,
    ):
        self.alt_text = alt_text
        self.path = path
        self.line_number = line_number
        self.markdown_file = markdown_file
        self.resolved_path = resolved_path
        self.exists = resolved_path.exists() if resolved_path else False

    def __repr__(self) -> str:
        return (
            f"ImageReference(path='{self.path}', line={self.line_number}, "
            f"exists={self.exists}, file='{self.markdown_file.name}')"
        )


class ValidationIssue:
    """Represents a validation issue found in markdown."""

    SEVERITY_ERROR = "error"
    SEVERITY_WARNING = "warning"
    SEVERITY_INFO = "info"

    def __init__(
        self,
        severity: str,
        message: str,
        image_ref: ImageReference,
        suggestion: Optional[str] = None,
    ):
        self.severity = severity
        self.message = message
        self.image_ref = image_ref
        self.suggestion = suggestion

    def __repr__(self) -> str:
        return (
            f"ValidationIssue({self.severity.upper()}: {self.message} "
            f"at {self.image_ref.markdown_file.name}:{self.image_ref.line_number})"
        )


class MarkdownImageValidator:
    """
    Validates image paths in markdown files.

    Checks:
    - Image files exist at specified paths
    - Relative paths are correct
    - Alt text is meaningful
    - All images in KB are referenced
    """

    # Regex for finding markdown image syntax: ![alt](path)
    IMAGE_PATTERN = re.compile(r"!\[([^\]]*)\]\(([^)]+)\)")

    # Common image extensions
    IMAGE_EXTENSIONS = {".jpg", ".jpeg", ".png", ".gif", ".svg", ".webp", ".bmp", ".tiff"}

    def __init__(self, kb_root: Path):
        """
        Initialize validator.

        Args:
            kb_root: Root path of knowledge base
        """
        self.kb_root = Path(kb_root).resolve()
        self.media_dir = self.kb_root / "media"

    def validate_markdown_file(
        self, markdown_file: Path, check_alt_text: bool = True
    ) -> Tuple[List[ImageReference], List[ValidationIssue]]:
        """
        Validate image references in a markdown file.

        Args:
            markdown_file: Path to markdown file
            check_alt_text: Whether to validate alt text quality

        Returns:
            Tuple of (list of image references, list of validation issues)
        """
        markdown_path = Path(markdown_file).resolve()

        if not markdown_path.exists():
            logger.error(f"Markdown file not found: {markdown_path}")
            return [], []

        # Read markdown content
        try:
            content = markdown_path.read_text(encoding="utf-8")
        except Exception as e:
            logger.error(f"Failed to read markdown file {markdown_path}: {e}")
            return [], []

        # Find all image references
        image_refs: List[ImageReference] = []
        issues: List[ValidationIssue] = []

        lines = content.split("\n")
        for line_num, line in enumerate(lines, start=1):
            matches = self.IMAGE_PATTERN.finditer(line)
            for match in matches:
                alt_text = match.group(1)
                img_path = match.group(2)

                # Skip URLs (http:// or https://)
                if img_path.startswith(("http://", "https://")):
                    continue

                # Resolve relative path from markdown file location
                markdown_dir = markdown_path.parent
                resolved_path = (markdown_dir / img_path).resolve()

                img_ref = ImageReference(
                    alt_text=alt_text,
                    path=img_path,
                    line_number=line_num,
                    markdown_file=markdown_path,
                    resolved_path=resolved_path,
                )

                image_refs.append(img_ref)

                # Validate image existence
                if not resolved_path.exists():
                    # Try to suggest correct path
                    suggestion = self._suggest_correct_path(img_path, markdown_path)
                    issues.append(
                        ValidationIssue(
                            severity=ValidationIssue.SEVERITY_ERROR,
                            message=f"Image file not found: {img_path} "
                            f"(resolved to: {resolved_path})",
                            image_ref=img_ref,
                            suggestion=suggestion,
                        )
                    )
                else:
                    # Check if resolved path is actually in KB media directory
                    try:
                        resolved_path.relative_to(self.media_dir)
                    except ValueError:
                        issues.append(
                            ValidationIssue(
                                severity=ValidationIssue.SEVERITY_WARNING,
                                message=f"Image is outside KB media directory: {resolved_path}",
                                image_ref=img_ref,
                            )
                        )

                # Validate alt text quality
                if check_alt_text:
                    alt_issues = self._validate_alt_text(alt_text, img_ref)
                    issues.extend(alt_issues)

        return image_refs, issues

    def _suggest_correct_path(self, img_path: str, markdown_path: Path) -> Optional[str]:
        """
        Suggest correct path if image exists but path is wrong.

        Args:
            img_path: Original (incorrect) image path
            markdown_path: Path to markdown file

        Returns:
            Suggested correct path or None
        """
        filename = Path(img_path).name

        if not self.media_dir.exists():
            return None

        candidates = [
            candidate for candidate in self.media_dir.rglob(filename) if candidate.is_file()
        ]

        best_path: Optional[str] = None
        best_score: Optional[Tuple[int, int, int]] = None

        for candidate in candidates:
            rel_path = self._make_relative_path(candidate, markdown_path.parent)
            if not rel_path:
                continue

            score = self._score_relative_path(rel_path)

            if best_score is None or score < best_score:
                best_path = rel_path
                best_score = score

        return best_path

    def _validate_alt_text(self, alt_text: str, img_ref: ImageReference) -> List[ValidationIssue]:
        """
        Validate quality of alt text.

        Args:
            alt_text: Alt text to validate
            img_ref: Image reference

        Returns:
            List of validation issues
        """
        issues: List[ValidationIssue] = []

        # Check if alt text is empty
        if not alt_text or not alt_text.strip():
            issues.append(
                ValidationIssue(
                    severity=ValidationIssue.SEVERITY_WARNING,
                    message="Empty alt text - images should have meaningful descriptions",
                    image_ref=img_ref,
                    suggestion="Add descriptive alt text explaining what the image shows",
                )
            )
        # Check if alt text is too generic
        elif alt_text.lower() in ["image", "img", "picture", "photo", "screenshot"]:
            issues.append(
                ValidationIssue(
                    severity=ValidationIssue.SEVERITY_INFO,
                    message=f"Generic alt text '{alt_text}' - consider more specific description",
                    image_ref=img_ref,
                    suggestion="Describe what the image shows, not just that it's an image",
                )
            )
        # Check if alt text is just filename
        elif alt_text in img_ref.path or img_ref.path.endswith(alt_text):
            issues.append(
                ValidationIssue(
                    severity=ValidationIssue.SEVERITY_INFO,
                    message="Alt text appears to be filename - use descriptive text instead",
                    image_ref=img_ref,
                    suggestion="Describe the content/purpose of the image",
                )
            )

        return issues

    def _make_relative_path(self, target: Path, start_dir: Path) -> Optional[str]:
        """
        Build a POSIX-style relative path from start_dir to target.
        """
        try:
            rel = os.path.relpath(target, start_dir)
        except ValueError:
            return None

        return PurePosixPath(rel).as_posix()

    def _score_relative_path(self, relative_path: str) -> Tuple[int, int, int]:
        """
        Score relative paths to choose the closest candidate.

        Lower scores are better. The tuple consists of:
        (number of upward ".." segments, total segments, total length)
        """
        segments = [segment for segment in relative_path.split("/") if segment]
        upwards = sum(1 for segment in segments if segment == "..")
        depth = len(segments)
        length = len(relative_path)
        return upwards, depth, length

    def validate_kb_directory(
        self, check_alt_text: bool = True
    ) -> Dict[str, List[ValidationIssue]]:
        """
        Validate all markdown files in KB directory.

        Args:
            check_alt_text: Whether to validate alt text quality

        Returns:
            Dict mapping markdown file paths to lists of validation issues
        """
        results: Dict[str, List[ValidationIssue]] = {}

        # Find all markdown files in KB
        for md_file in self.kb_root.rglob("*.md"):
            if md_file.is_file():
                _, issues = self.validate_markdown_file(md_file, check_alt_text)
                if issues:
                    # Store relative path for cleaner output
                    try:
                        rel_path = md_file.relative_to(self.kb_root)
                        results[str(rel_path)] = issues
                    except ValueError:
                        results[str(md_file)] = issues

        return results

    def find_unreferenced_images(self) -> List[Path]:
        """
        Find images in KB that are not referenced by any markdown file.

        Returns:
            List of unreferenced image file paths
        """
        if not self.media_dir.exists():
            return []

        # Collect all image files
        all_images: Set[Path] = set()
        for img_ext in self.IMAGE_EXTENSIONS:
            all_images.update(self.media_dir.glob(f"*{img_ext}"))

        # Collect all referenced images
        referenced_images: Set[Path] = set()
        for md_file in self.kb_root.rglob("*.md"):
            if md_file.is_file():
                refs, _ = self.validate_markdown_file(md_file, check_alt_text=False)
                for ref in refs:
                    if ref.resolved_path and ref.resolved_path.exists():
                        referenced_images.add(ref.resolved_path)

        # Find unreferenced images
        unreferenced = all_images - referenced_images
        return sorted(unreferenced)

    def generate_report(
        self, issues_by_file: Dict[str, List[ValidationIssue]], verbose: bool = False
    ) -> str:
        """
        Generate human-readable validation report.

        Args:
            issues_by_file: Dict mapping file paths to validation issues
            verbose: Include all info-level issues in report

        Returns:
            Formatted report string
        """
        lines = ["=" * 80, "MARKDOWN IMAGE VALIDATION REPORT", "=" * 80, ""]

        total_errors = 0
        total_warnings = 0
        total_info = 0

        if not issues_by_file:
            lines.append("âœ… No validation issues found!")
            lines.append("")
        else:
            lines.append(f"Found issues in {len(issues_by_file)} file(s):")
            lines.append("")

            for file_path, issues in sorted(issues_by_file.items()):
                lines.append(f"ðŸ“„ {file_path}")
                lines.append("-" * 80)

                for issue in issues:
                    if issue.severity == ValidationIssue.SEVERITY_ERROR:
                        icon = "âŒ"
                        total_errors += 1
                    elif issue.severity == ValidationIssue.SEVERITY_WARNING:
                        icon = "âš ï¸"
                        total_warnings += 1
                    else:
                        icon = "â„¹ï¸"
                        total_info += 1
                        if not verbose:
                            continue  # Skip info in non-verbose mode

                    lines.append(f"  {icon} Line {issue.image_ref.line_number}: {issue.message}")
                    lines.append(f"     Image path: {issue.image_ref.path}")
                    if issue.suggestion:
                        lines.append(f"     ðŸ’¡ Suggestion: {issue.suggestion}")
                    lines.append("")

        # Summary
        lines.append("=" * 80)
        lines.append("SUMMARY")
        lines.append("=" * 80)
        lines.append(f"âŒ Errors:   {total_errors}")
        lines.append(f"âš ï¸  Warnings: {total_warnings}")
        if verbose:
            lines.append(f"â„¹ï¸  Info:     {total_info}")
        lines.append("")

        return "\n".join(lines)


def validate_agent_generated_markdown(
    markdown_file: Path, kb_root: Path, auto_fix: bool = False
) -> bool:
    """
    Validate markdown file generated by agent and optionally fix issues.

    Args:
        markdown_file: Path to markdown file to validate
        kb_root: Root path of knowledge base
        auto_fix: Whether to attempt automatic fixes (NOT IMPLEMENTED YET)

    Returns:
        True if validation passed (no errors), False otherwise
    """
    validator = MarkdownImageValidator(kb_root)
    image_refs, issues = validator.validate_markdown_file(markdown_file)

    # Filter only errors
    errors = [i for i in issues if i.severity == ValidationIssue.SEVERITY_ERROR]

    if errors:
        logger.error(f"Image validation failed for {markdown_file.name}: {len(errors)} error(s)")
        for error in errors:
            logger.error(f"  Line {error.image_ref.line_number}: {error.message}")
            if error.suggestion:
                logger.info(f"    Suggestion: {error.suggestion}")
        return False

    # Log warnings
    warnings = [i for i in issues if i.severity == ValidationIssue.SEVERITY_WARNING]
    if warnings:
        logger.warning(
            f"Image validation warnings for {markdown_file.name}: {len(warnings)} warning(s)"
        )
        for warning in warnings:
            logger.warning(f"  Line {warning.image_ref.line_number}: {warning.message}")

    logger.info(f"Image validation passed for {markdown_file.name}")
    return True


def validate_kb_images(kb_root: Path, verbose: bool = False) -> int:
    """
    Validate all images in knowledge base and generate report.

    Args:
        kb_root: Root path of knowledge base
        verbose: Include info-level issues in report

    Returns:
        Number of errors found (0 means validation passed)
    """
    validator = MarkdownImageValidator(kb_root)

    # Validate all markdown files
    logger.info(f"Validating markdown files in {kb_root}...")
    issues_by_file = validator.validate_kb_directory(check_alt_text=verbose)

    # Generate report
    report = validator.generate_report(issues_by_file, verbose=verbose)
    print(report)

    # Find unreferenced images
    unreferenced = validator.find_unreferenced_images()
    if unreferenced:
        print("=" * 80)
        print(f"UNREFERENCED IMAGES ({len(unreferenced)})")
        print("=" * 80)
        for img in unreferenced:
            try:
                rel_path = img.relative_to(kb_root)
                print(f"  ðŸ“¸ {rel_path}")
            except ValueError:
                print(f"  ðŸ“¸ {img}")
        print("")

    # Count errors
    total_errors = sum(
        1
        for issues in issues_by_file.values()
        for issue in issues
        if issue.severity == ValidationIssue.SEVERITY_ERROR
    )

    return total_errors
